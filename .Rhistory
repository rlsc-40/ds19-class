#plotting Biketown trip data with Base R
install.packages(tidyverse)
#plotting Biketown trip data with Base R
install.packages("tidyverse")
library(tidyverse)
#plotting Biketown trip data with Base R
install.packages("tidyverse") #just for installing, won't need again
library(tidyverse)
#plotting Biketown trip data with Base R
install.packages("tidyverse") #just for installing, won't need again
biketown <- read.csv("data/biketown-2018-trips.csv")
library(tidyverse)
install.packages("ggplot2")
str(biketown)
summary(biketown)
install.packages("ggplot2") #also didn't work - keeps asking about compilation pkgs
library(ggplot2)
install.packages("ggplot2") #also didn't work - keeps asking about compilation pkgs
#plotting Biketown trip data with Base R
install.packages("tidyverse") #just for installing, won't need again
library(tidyverse) #not working!
library(ggplot2)
library("ggplot2")
library("dplyr")
install.packages("dplyr")
library("dplyr")
install.packages("tidyverse")
library(tidyverse) #not working!
library(lubridate)
biketown$hour <-
hms(biketown$StartTime) %>%
hour()
table(biketown$hour)
View(biketown)
#hms --> hour, minute, second; we extracted the hour
freq_by_hr <- table(biketown$hour)
barplot(freq_by_hr)
barplot(40000,freq_by_hr)
barplot(freq_by_hr)
View(biketown)
barplot(biketown$Month)
freq_by_month <- table(biketown$month)
barplot(freq_by_month)
hist(biketown$hour)
hist(biketown$hour, breaks = seq(0, 24, 3))
# focus on a.m. peak
am_peak <- subset(biketown, hour >= 7 & hour < 10)
View(am_peak)
View(am_peak)
hist(am_peak)
hist(am_peak$hour)
hist(am_peak$hour, breaks = seq(7, 10, 1))
barplot(table(am_peak$hour))
# the comma indicates a condition; can accomplish the same using the brackets like day 1
pm_peak <- biketown[levels(biketown$hour) >= 16 & hour < 20, ]
pm_peak <- biketown[(biketown$hour) >= 16 & hour < 20, ]
pm_peak <- subset(biketown, hour >= 16 & hour < 20)
hist(pm_peak$hour)
View(biketown)
biketown$month <-
mdy(biketown$StartDate) %>%
month(label = T, abbr = T)
str(biketown$month)
# looking at seasonal patterns
freq_by_month <- table(biketown$month)
barplot(freq_by_month) # gives to us in alphabetical order, was brought in as a factor
summary(biketown)
str(biketown)
freq_by_station <- table(biketown$StartHub)
# top 25 stations
s <- sort(freq_by_station, decreasing = T)
top25 <- s[1:25]
# could have written: top25 <- sort(freq_by_station, decreasing = T)
dotchart(top25)
git status
# make url function only available within get_data
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv") #the cap Y tells it we want the
# four-char year; %Y%m is a formatting aspect in baseR
return(url)
}
get_data <- function(start="7/2016", end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
# takes start and end in mm/yyyy format, and tries to download files
# if no end date given, set to now
# setting parameter values within the function
# end <- ifelse(is.null(end), format(now(), "%m/%Y"), end)
# make url function only available within get_data
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv") #the cap Y tells it we want the
# four-char year; %Y%m is a formatting aspect in baseR
return(url)
}
get_data <- function(start="7/2016", end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
# takes start and end in mm/yyyy format, and tries to download files
# if no end date given, set to now
# setting parameter values within the function
# end <- ifelse(is.null(end), format(now(), "%m/%Y"), end)
# make url function only available within get_data
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv") #the cap Y tells it we want the
# four-char year; %Y%m is a formatting aspect in baseR
return(url)
}
# parse date range
start_date <- lubridate::myd(start, truncated = 2)
end_date <- myd(end, truncated = 2)
date_range <- seq(start_date, end_date,by="months")
# function starting to get really long, may need to debug as we go along
# lapply(a, b) just applies function b to sequence a
# and returns a list of the modified sequence
urls <- lapply(date_range, make_url, base_url=base_url)
# for loops can be easier for early development of code (a little more readable)
for (u in urls) { # "u" is just a name, could be "x", etc.
download.file(u, destfile = paste0(outdir, str_sub(u, -11))) #just pulls last 11 chars
}
}
start = "6/2018"
end = "8/2018"
# outdir = "Users/rebecca/Desktop/"
outdir = "biketown/"
outdir = "data/biketown/"
get_data(start, end, outdir = outdir)
# Analyze some biketown trip data
source("code/fetch_biketown.R")
get_data <- function(start="7/2016", end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
# takes start and end in mm/yyyy format, and tries to download files
# if no end date given, set to now
# setting parameter values within the function
# end <- ifelse(is.null(end), format(now(), "%m/%Y"), end)
# make url function only available within get_data
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv") #the cap Y tells it we want the
# four-char year; %Y%m is a formatting aspect in baseR
return(url)
}
# parse date range
start_date <- lubridate::myd(start, truncated = 2)
end_date <- myd(end, truncated = 2)
date_range <- seq(start_date, end_date,by="months")
# function starting to get really long, may need to debug as we go along
# lapply(a, b) just applies function b to sequence a
# and returns a list of the modified sequence
urls <- lapply(date_range, make_url, base_url=base_url)
# for loops can be easier for early development of code (a little more readable)
for (u in urls) { # "u" is just a name, could be "x", etc.
download.file(u, destfile = paste0(outdir, str_sub(u, -11))) #just pulls last 11 chars
}
}
start = "6/2018"
end = "8/2018"
# outdir = "Users/rebecca/Desktop/"
outdir = "data/biketown/"
get_data(start, end, outdir = outdir)
}
}
get_data <- function(start, end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
# takes start and end in mm/yyyy format, and tries to download files
# if no end date given, set to now
# setting parameter values within the function
# end <- ifelse(is.null(end), format(now(), "%m/%Y"), end)
# make url function only available within get_data
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv") #the cap Y tells it we want the
# four-char year; %Y%m is a formatting aspect in baseR
return(url)
}
# parse date range
start_date <- lubridate::myd(start, truncated = 2)
end_date <- myd(end, truncated = 2)
date_range <- seq(start_date, end_date,by="months")
# function starting to get really long, may need to debug as we go along
# lapply(a, b) just applies function b to sequence a
# and returns a list of the modified sequence
urls <- lapply(date_range, make_url, base_url=base_url)
# for loops can be easier for early development of code (a little more readable)
for (u in urls) { # "u" is just a name, could be "x", etc.
download.file(u, destfile = paste0(outdir, str_sub(u, -11))) #just pulls last 11 chars
}
# 2) as an apply with an in-line function
# result <- lapply(urls, (u, function (u) {
#   download.file(u, destfile = paste0(outdir, str_sub(u, -11)))
# })
}
source('~/Desktop/DS19-class/ds19-class/code/fetch_biketown.R', echo=TRUE)
get_data(start, end, outdir = outdir)
start = "6/2018"
end = "8/2018"
# outdir = "Users/rebecca/Desktop/"
outdir = "data/biketown/"
get_data(start, end, outdir = outdir)
get_data <- function(start, end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
# takes start and end in mm/yyyy format, and tries to download files
# if no end date given, set to now
# setting parameter values within the function
# end <- ifelse(is.null(end), format(now(), "%m/%Y"), end)
# make url function only available within get_data
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv") #the cap Y tells it we want the
# four-char year; %Y%m is a formatting aspect in baseR
return(url)
}
# parse date range
start_date <- lubridate::myd(start, truncated = 2)
end_date <- myd(end, truncated = 2)
date_range <- seq(start_date, end_date,by="months")
# function starting to get really long, may need to debug as we go along
# lapply(a, b) just applies function b to sequence a
# and returns a list of the modified sequence
urls <- lapply(date_range, make_url, base_url=base_url)
# for loops can be easier for early development of code (a little more readable)
for (u in urls) { # "u" is just a name, could be "x", etc.
download.file(u, destfile = paste0(outdir, str_sub(u, -11))) #just pulls last 11 chars
}
# 2) as an apply with an in-line function
# result <- lapply(urls, (u, function (u) {
#   download.file(u, destfile = paste0(outdir, str_sub(u, -11)))
# })
}
# can differentiate between required (x, ...) and default (y = ...)
# for loops are expensive because it loops each time. But good for checking if apply not working.
# Apply is a better option when possible in R; in Python and Stata, for loops are std.
# at this point, we have not called the function - have just assigned it.
### manual run ###
# params
start = "6/2018"
end = "8/2018"
# outdir = "Users/rebecca/Desktop/"
outdir = "data/biketown/"
get_data(start, end, outdir = outdir)
if (!require("lubridate"))(install.packages("lubridate")); library(lubridate)
if (!require("dplyr"))(install.packages("dplyr")); library(dplyr)
if (!require("stringr"))(install.packages("stringr")); library(stringr)
if (!require("readr"))(install.packages("readr")); library(readr)
# could also have done (simpler)
# pkgs <- c("lubridate", "dplyr", "stringr", "readr")
# install.packages(pkgs)
# will now write function to download data from biketown
# 3 ways to the same end
get_data <- function(start, end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
# takes start and end in mm/yyyy format, and tries to download files
# if no end date given, set to now
# setting parameter values within the function
# end <- ifelse(is.null(end), format(now(), "%m/%Y"), end)
# make url function only available within get_data
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv") #the cap Y tells it we want the
# four-char year; %Y%m is a formatting aspect in baseR
return(url)
}
# parse date range
start_date <- lubridate::myd(start, truncated = 2)
end_date <- myd(end, truncated = 2)
date_range <- seq(start_date, end_date,by="months")
# function starting to get really long, may need to debug as we go along
# lapply(a, b) just applies function b to sequence a
# and returns a list of the modified sequence
urls <- lapply(date_range, make_url, base_url=base_url)
# for loops can be easier for early development of code (a little more readable)
for (u in urls) { # "u" is just a name, could be "x", etc.
download.file(u, destfile = paste0(outdir, str_sub(u, -11))) #just pulls last 11 chars
}
# 2) as an apply with an in-line function
# result <- lapply(urls, (u, function (u) {
#   download.file(u, destfile = paste0(outdir, str_sub(u, -11)))
# })
}
# can differentiate between required (x, ...) and default (y = ...)
# for loops are expensive because it loops each time. But good for checking if apply not working.
# Apply is a better option when possible in R; in Python and Stata, for loops are std.
# at this point, we have not called the function - have just assigned it.
### manual run ###
# params
start = "6/2018"
end = "8/2018"
# outdir = "Users/rebecca/Desktop/"
outdir = "data/biketown/"
get_data(start, end, outdir = outdir)
# trying to rerun to figure out what is going on
source("code/fetch_biketown.R")
get_data(start = "06/2018", end = "08/2018")
#trying a different way
get_data <- function(start, end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv")
return(url)
}
start_date <- lubridate::myd(start, truncated = 2)
end_date <- myd(end, truncated = 2)
date_range <- seq(start_date, end_date,by="months")
urls <- lapply(date_range, make_url, base_url=base_url)
# for loops can be easier for early development of code (a little more readable)
# for (u in urls) { # "u" is just a name, could be "x", etc.
#   download.file(u, destfile = paste0(outdir, str_sub(u, -11))) #just pulls last 11 chars
# }
# 2) as an apply with an in-line function
result <- lapply(urls, function (u) {
download.file(u, destfile = paste0(outdir, str_sub(u, -11)))
})
}
library("magrittr", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
get_data <- function(start, end,
base_url="https://s3.amazonaws.com/biketown-tripdata-public/",
outdir="Users/rebecca/Desktop/DS19-class/ds19-class/data/biketown/") {
make_url <- function(date, base_url) {
url <- paste0(base_url, format(date, "%Y_%m"), ".csv")
return(url)
}
start_date <- lubridate::myd(start, truncated = 2)
end_date <- myd(end, truncated = 2)
date_range <- seq(start_date, end_date,by="months")
lapply(date_range, make_url, base_url=base_url) %>%
lapply(function (u) {download.file(u, destfile = paste0(outdir, str_sub(u, -11)))
})
}
start = "11/2018"
end = "12/2018"
# outdir = "Users/rebecca/Desktop/"
outdir = "data/biketown/"
get_data(start, end, outdir = outdir)
install.packages(yaml)
library("yaml", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("yaml", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
install.packages("yaml")
library(yaml)
knitr::opts_chunk$set(echo = TRUE)
# this is where we would say, "Don't show this code, just show the output"
# clean up the data, generate plot, write something descriptive
bike_1807 <- read.csv("data/biketown/2018_07.csv", stringsAsFactors = F)
library(dplyr)
library(lubridate)
library(ggplot2)
str(bike_1807)
mean(Distance_Miles), group_by(PaymentPlan)
mean(Distance_Miles)
dplyr::mean(Distance_Miles)
dplyr::mean(bike_1807$Distance_Miles)
mean(bike_1807$Distance_Miles)
mean <- mean(bike_1807$Distance_Miles) %>%
group_by(mean)
mean <- mean(bike_1807$Distance_Miles) %>%
group_by(mean(bike_1807$Distance_Miles))
mean <- mean(bike_1807$Distance_Miles) %>%
dplyr::group_by(mean(bike_1807$Distance_Miles))
mean_dist <- bike_1807 %>%
group_by(PaymentPlan) %>%
summarise(mean_dist = mean(Distance_Miles))
mean
mean_dist
b <- ggplot(mpg, aes(fl))
b+geom_bar(mean_dist)
b <- ggplot(bike_1807, aes(fl))
b+geom_bar(mean_dist)
barplot(bike_1807$mean_dist)
barplot(table(bike_1807$mean_dist))
md_fig <- mean_dist %>%
ggplot(aes(x = PaymentPlan, y = mean_dist)) +
geom_bar(stat = "identity")
mean_dist <- bike_1807 %>%
group_by(PaymentPlan) %>%
summarise(mean_miles = mean(Distance_Miles))
mean_dist
md_fig <- mean_dist %>%
ggplot(aes(x = PaymentPlan, y = mean_miles)) +
geom_bar(stat = "identity")
md_fig
md_fig <- mean_dist %>%
ggplot(aes(x = PaymentPlan, y = mean_miles, fill = PaymentPlan)) +
geom_bar(stat = "identity")
md_fig
install.packages(DT)
install.packages(DT)
install.packages(DT)
install.packages("DT")
library(DT)
datatable(pay_miles, options = list(
pagelength = 15),
caption = 'Table 1: Table of values'
)
datatable(mean_dist, options = list(
pagelength = 15),
caption = 'Table 1: Table of values'
)
mean_dist2 <- bike_1807 %>%
group_by(PaymentPlan, MultipleRental) %>%
summarise(mean_miles = mean(Distance_Miles))
library("dbplyr", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("ggplot2", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("lubridate", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library(dplyr)
library(lubridate)
library(ggplot2)
mean_dist2 <- bike_1807 %>%
group_by(PaymentPlan, MultipleRental) %>%
summarise(mean_miles = mean(Distance_Miles))
mean_dist2
datatable(mean_dist, options = list(
pagelength = 15),
caption = 'Table 1: Table of values'
)
library(ggthemes)
install.packages("ggthemes")
library(ggthemes)
library(extrafont)
md_fig2 <- mean_dist2 %>%
ggplot(aes(x = PaymentPlan, y = mean_miles, fill = PaymentPlan)) +
geom_bar(stat = "identity")
md_fig2
md_fig2 <- mean_dist2 %>%
ggplot(aes(x = PaymentPlan, y = mean_miles, fill = MultipleRental)) +
geom_bar(stat = "identity")
# fill is how to make it colored; can customize via more in-depth exploration
md_fig2
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(lubridate)
library(ggplot2)
install.packages("DT")
library(DT)
install.packages("ggthemes")
library(ggthemes)
library(extrafont)
